//VulnerabilityScanService
package com.example.SecureNet.Service;

import com.example.SecureNet.Model.Vulnerability;
import com.example.SecureNet.Repository.VulnerabilityRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class VulnerabilityScanService {

    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    public static final String NIKTO_LOG_FILE_PATH = "C:/Users/dell/nikto/logs/nikto.log";
    private static final Pattern VULNERABILITY_PATTERN = Pattern.compile("\\+\\s+(GET|POST|OPTIONS)\\s+(.*?):\\s*(.*)");


    public List<Vulnerability> getVulnerabilitiesByWebsite(String websiteName) {
        System.out.println("Website name received: " + websiteName);
        List<Vulnerability> results = vulnerabilityRepository.findByTargetUrlContaining(websiteName);
        System.out.println("Fetched vulnerabilities from DB: " + results);
        return results;
    }


    // Method to run a real-time Nikto scan
    public List<Vulnerability> runRealTimeScan(String websiteName) {
        System.out.println("Running real-time Nikto scan for website: " + websiteName);
        List<String> outputLines = new ArrayList<>();
        Process process = null;

        try {
            // Updated Nikto command using PowerShell and tee
            String command = "powershell -Command \"perl C:/Users/dell/nikto/program/nikto.pl -h " + websiteName + " -Format txt | tee C:/Users/dell/nikto/logs/nikto.log\"";
            System.out.println("Executing Nikto command: " + command);

            // Execute the Nikto command
            process = Runtime.getRuntime().exec(command);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));

            // Capture output stream
            Thread outputThread = new Thread(() -> {
                try {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println("Nikto output: " + line);
                        outputLines.add(line);
                    }
                } catch (IOException e) {
                    System.err.println("Error reading Nikto output: " + e.getMessage());
                }
            });

            // Capture error stream
            Thread errorThread = new Thread(() -> {
                try {
                    String errorLine;
                    boolean hasErrors = false;
                    while ((errorLine = errorReader.readLine()) != null) {
                        hasErrors = true;
                        System.err.println("Nikto error: " + errorLine);
                    }
                    if (!hasErrors) {
                        System.out.println("No errors captured from Nikto process.");
                    }
                } catch (IOException e) {
                    System.err.println("Error reading Nikto error stream: " + e.getMessage());
                }
            });

            System.out.println("Nikto process started. PID: " + process.pid() + ", isAlive: " + process.isAlive());
            outputThread.start();
            errorThread.start();

            // Wait for up to 4 minutes (240 seconds)
            System.out.println("Waiting for Nikto process to finish (up to 4 minutes)...");
            boolean finished = process.waitFor(240, TimeUnit.SECONDS);

            if (finished) {
                System.out.println("Nikto scan completed successfully.");
            } else {
                System.out.println("Nikto scan timeout reached after 4 minutes. Forcefully terminating the process.");
                process.destroyForcibly();
            }

            // Print log file content
            printLogFileContent();

            // Wait for the output threads to complete
            outputThread.join();
            errorThread.join();

            // Parse the saved log file
            return parseAndSaveVulnerabilities(websiteName);

        } catch (IOException | InterruptedException e) {
            System.err.println("Error running Nikto scan: " + e.getMessage());
            e.printStackTrace();
            return new ArrayList<>();
        } finally {
            if (process != null && process.isAlive()) {
                System.out.println("Forcibly terminating the Nikto process in finally block.");
                process.destroyForcibly();
            }
        }
    }



    // Method to print the content of the log file for debugging
 // Method to print the content of the log file for debugging
    private void printLogFileContent() {
        System.out.println("Printing log file content:");

        File logFile = new File(NIKTO_LOG_FILE_PATH);

        // Wait until the log file has content
        int attempts = 0;
        while (logFile.length() == 0 && attempts < 10) {
            System.out.println("Log file is empty. Waiting for content (attempt " + (attempts + 1) + ")...");
            try {
                Thread.sleep(10000); // Wait for 10 seconds
            } catch (InterruptedException e) {
                System.err.println("Interrupted while waiting for log file content: " + e.getMessage());
            }
            attempts++;
        }

        if (logFile.length() == 0) {
            System.err.println("Log file is still empty after multiple attempts. Skipping parsing.");
            return;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading the log file: " + e.getMessage());
        }
    }


    // Method to parse the Nikto log file and save vulnerabilities
    private List<Vulnerability> parseAndSaveVulnerabilities(String websiteName) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        System.out.println("Starting to parse the Nikto log file: " + NIKTO_LOG_FILE_PATH);

        File logFile = new File(NIKTO_LOG_FILE_PATH);
        if (!logFile.exists() || logFile.length() == 0) {
            System.out.println("Log file is empty or does not exist. Skipping parsing.");
            return vulnerabilities;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(NIKTO_LOG_FILE_PATH))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println("Reading line: " + line);

                Matcher matcher = VULNERABILITY_PATTERN.matcher(line);
                if (matcher.find()) {
                    String requestType = matcher.group(1);
                    String targetEndpoint = matcher.group(2);
                    String description = matcher.group(3);

                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setDescription(description);
                    vulnerability.setSeverity("Medium");
                    vulnerability.setTargetUrl(websiteName + targetEndpoint);
                    vulnerability.setTimestamp(LocalDateTime.now().toString());

                    saveVulnerability(vulnerability);
                    vulnerabilities.add(vulnerability);
                    System.out.println("Parsed and saved vulnerability: " + vulnerability);
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading the log file: " + e.getMessage());
        }

        System.out.println("Total vulnerabilities parsed and saved: " + vulnerabilities.size());
        return vulnerabilities;
    }

    // Method to save a vulnerability
    public void saveVulnerability(Vulnerability vulnerability) {
        vulnerabilityRepository.save(vulnerability);
        System.out.println("Vulnerability saved: " + vulnerability.getDescription());
    }
}
